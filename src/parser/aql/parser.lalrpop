use std::*;
use super::ast;

grammar;

pub Query : ast::Expr = {
    <c:Conjunction> => c,
}

Conjunction : ast::Expr = {
    NodeSearch ( "&" Conjunction) => ast::Expr::Empty,
    BinaryOp ("&" Conjunction) => ast::Expr::Empty,
}

NodeSearch : ast::Expr = {
    TextSearch => ast::Expr::Empty,
    QName "=" TextSearch => ast::Expr::Empty,
    QName =>  ast::Expr::Empty,
}

BinaryOp : ast::Expr = {
    <lhs:r##"#[0-9]+"##> BinaryOpSpec <rhs:r##"#[0-9]+"##> => ast::Expr::Empty,
}

BinaryOpSpec : ast::BinaryOpType = {
    ">" => ast::BinaryOpType::Dominance,
    "->" => ast::BinaryOpType::Pointing,
    "." => ast::BinaryOpType::Precedence,
    "_o_" => ast::BinaryOpType::Overlap,
    "_=_" => ast::BinaryOpType::IdenticalCoverage,
}

TextSearch: ast::TextSearch = {
    <v:r#""[^"]*""#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Exact),
    // see https://stackoverflow.com/questions/37032620/regex-for-matching-a-string-literal-in-java 
    // for a example how to match escaped quotation characters
    <v:r#"/[^"\\]*(\\.[^"\\]*)*/"#> => ast::TextSearch(String::from(&v[1..v.len()-1]), ast::StringMatchType::Regex),
};

QName: ast::QName = {
    <ns:r"[a-zA-Z][a-zA-Z0-9]*"> ":" <name:r"[a-zA-Z][a-zA-Z0-9]*"> => ast::QName(Some(String::from(ns)), String::from(name)),
    <name:r"[a-zA-Z][a-zA-Z0-9]*"> => ast::QName(None, String::from(name)),
    
};


